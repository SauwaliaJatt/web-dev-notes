<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Node JS Notes</title>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600&display=swap"
        rel="stylesheet" />

    <style>
        /* Reset & Global */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f2f2f2;
            color: #212121;
            line-height: 1.8;
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            background: linear-gradient(180deg, #1a1a1a, #333);
            color: #fff;
            padding: 25px 18px;
            overflow-y: auto;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.2);
            z-index: 999;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin: 18px 0;
        }

        .sidebar a {
            color: #fff;
            text-decoration: none;
            font-size: 1.15rem;
            display: block;
            padding: 10px 18px;
            border-radius: 6px;
            font-weight: 500;
            transition: background-color 0.3s, box-shadow 0.3s;
        }

        .sidebar a:hover{
            background-color: #43a047;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
            color: #e8f5e9;
        }

        /* Main Content */
        main {
            margin-left: 260px;
            padding: 30px 40px;
            width: calc(100% - 260px);
            background-color: #f2f2f2;
        }

        /* Note Section Container */
        .note-section {
            background-color: #fff;
            padding: 30px 25px;
            border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.5);
            margin-bottom: 50px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        /* .note-section:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.12);
        } */

        .container {
            max-width: 1100px;
            margin: 0 auto;
        }

        /* Level 1 Notes */
        .note-l1 {
            margin-bottom: 30px;
        }

        .note-l1 h2 {
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            color: #2e7d32;
            background-color: #e8f5e9;
            padding: 5px 18px;
            border-left: 5px solid #2e7d32;
            border-radius: 5px;
            /* position: sticky; */
            /* top: 0; */
            /* z-index: 10; */
        }

        .note-l1 p {
            font-size: 1.3rem;
            color: #232323;
            margin-top: 15px;
        }

        /* Notes Grid */
        .notes {
            display: grid;
            /* grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); */
            gap: 22px;
            margin-top: 25px;
        }

        /* Level 2 Notes */
        .note-l2 {
            background-color: #ffffff;
            padding: 22px 20px;
            border-top: 4px solid #0288d1;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: box-shadow 0.3s ease, transform 0.3s ease;
        }

        /* .note-l2:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
        } */

        .note-l2 h3 {
            font-size: 1.6rem;
            font-weight: 600;
            color: #014f86;
            margin-bottom: 8px;
        }

        .note-l2 p {
            font-size: 1.15rem;
            color: #555;
            margin-bottom: 18px;
            margin-top: 20px;
        }

        /* Level 3 Notes */
        .note-l3 {
            background-color: #f9f9f9;
            padding: 16px 14px;
            margin: 18px 0 18px 10px;
            border-left: 5px solid #7b1fa2;
            border-radius: 7px;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
        }

        .note-l3 h4 {
            font-size: 1.3rem;
            font-weight: 500;
            color: #4a148c;
            margin-bottom: 10px;
        }

        .note-l3 p {
            font-size: 1.15rem;
            color: #353535;
        }

        /* Code Section Style */
        .code-container {
            background-color: #272822;
            padding: 15px 20px;
            /* border-left: 5px solid #66d9ef; */
            border-radius: 8px;
            overflow-x: auto;
            margin: 0 0 15px;
            width: 100%;
            display: inline-block;
            text-align: left;
        }

        .code-container code {
            color: #f8f8f2;
            font-size: 16px;
            font-family: monospace;
            white-space: pre-line;
            display: block;
            line-height: 2rem;
            margin: 0;
            padding: 0;
        }

        .code-container code::first-line {
            line-height: 0;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            font-size: 1rem;
            color: #333;
        }

        table,th,td {
            border: 3px solid #858080;
            padding: 14px 16px;
        }

        th {
            background-color: #f0f0f0;
            font-weight: 700;
            color: #222;
        }

        caption {
            font-size: 1.25rem;
            margin-bottom: 12px;
            font-weight: 600;
            color: #2e7d32;
        }

        .bolder {
            font-weight: 700;
        }

        /* lists ul, ol */
        ul:not(.sidebar ul), ol:not(.sidebar ol)  {
            padding-left: 25px;
            margin-bottom: 20px;
            color: #444;
            font-size: 1.2rem;
        }

        ul :not(.sidebar) li {
            list-style-type: disc;
            margin-bottom: 10px;
        }

        ol :not(.sidebar) li {
            list-style-type: decimal;
            margin-bottom: 10px;
        }


        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-260px);
                width: 220px;
                transition: transform 0.3s ease;
            }

            .sidebar.active {
                transform: translateX(0);
            }

            main {
                margin-left: 0;
                width: 100%;
                padding: 25px 20px;
            }

            .notes {
                grid-template-columns: 1fr;
            }

            .note-l1 h2 {
                position: static;
                border-radius: 5px;
            }
        }

        /* Mobile Menu Toggle Button */
        .menu-toggle {
            display: none;
            position: fixed;
            top: 18px;
            left: 18px;
            background-color: #2e7d32;
            color: #fff;
            border: none;
            padding: 11px 16px;
            border-radius: 6px;
            cursor: pointer;
            z-index: 1000;
            font-size: 1.1rem;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            user-select: none;
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
            }
        }
    </style>
</head>

<body>
    <!-- Sidebar & Menu Toggle -->
    <button class="menu-toggle" aria-label="Toggle menu">☰ Menu</button>
    <nav class="sidebar" aria-label="Sidebar Navigation">
        <ul>
            <li><a href="#section1">Node.js</a></li>
            <li><a href="#section2">process Object</a></li>
            <li><a href="#section3">Export in files</a></li>
            <li><a href="#section4">Export in directories</a></li>
            <li><a href="#section5">NPM</a></li>
            <hr>
            <li><a href="#section6">Express.js</a></li>
            <li><a href="#section7">Handling Requests</a></li>
            <li><a href="#section8">Sending Response</a></li>
            <li><a href="#section9">Routing</a></li>
            <li><a href="#section10">GET/POST Request</a></li>
            <li><a href="#section10i">Middlewares</a></li>
            <li><a href="#section10ii">Error Handeling</a></li>
            <li><a href="#section10iii">Schema Validation</a></li>
            <hr>
            <li><a href="#section11">EJS</a></li>
            <li><a href="#section12">Interpolation Syntax</a></li>
            <li><a href="#section13">Passing data to ejs</a></li>
            <li><a href="#section14">Includes</a></li>
            <hr>
            <li><a href="#section15">REST</a></li>
            <li><a href="#section16">How to Create Unique IDs</a></li>
            <li><a href="#section17">Use PUT, PATCH, DELETE in html</a></li>
        </ul>
    </nav>

    <main>
        <!-- Node js -->
        <section id="section1" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Node.js</h2>
                    <p>
                        Node.js is a cross-platform runtime environment that allows you to run JavaScript outside of a web browser—usually on a server. It enables developers to build fast, scalable server-side and network applications using JavaScript. <br>
                        extension → <span class="bolder">.js</span> (any js file).
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>node REPL</h3>
                        <p>
                            REPL stands for: Read → Eval → Print → Loop. The Node.js REPL is an interactive shell that lets you run JavaScript line-by-line directly in the terminal.
                        </p>
                        <div class="notes">
                            <div class="note-l3">
                                <h4>How to Start REPL:</h4>
                                <ol>
                                    <li>Open your terminal</li>
                                    <li>Type: node</li>
                                    <li>You'll see a > prompt. Start typing JavaScript code.</li>
                                    <li>To exit REPL, press: Ctrl + C (twice) or type .exit</code></li>
                                </ol>
                            </div>                   
                        </div>
                        <p>
                            to run Javascript with node in terminal use "node fileName.js". You need to be in same folder where file is present
                        </p>
                    </article>
                </div>
            </div>
        </section>

        <!-- Process Object -->
        <section id="section2" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>process Object</h2>
                    <p>
                        In Node.js, the process object is a global object that provides information and control over the current Node.js process. It's part of the core process module, so you don't need to import it.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Key Properties of the process Object</h3>
                        <p>
                            <span class="bolder">process.argv:</span> An array containing the command-line arguments passed when the Node.js process was launched. The first element is the path to the Node.js executable, the second is the path to the script, and subsequent elements are additional arguments.
                        </p>
                        <div class="code-container">
                            <code>
                                Example:
                                // Example: node script.js arg1 arg2
                                console.log(process.argv); 
                                //Output like:  ['node', 'path/to/script.js', 'arg1', 'arg2']
                            </code>
                        </div>
                        <p>
                            There are many more properties and Methods in process Object...
                        </p>
                    </article>
                </div>
            </div>
        </section>

        <!-- export in files -->
        <section id="section3" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Export in files</h2>
                    <p>
                        In Node.js, module.exports and require() are core concepts for creating and using modules to organize and share code.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>module.exports</h3>
                        <p>
                            module.exports is an object in a Node.js module that defines what a module exposes to other parts of the application. By default, it's an empty object ({}), but you can assign functions, objects, or values to it.
                        </p>
                        <p>
                            <span class="bolder">Purpose:</span> It determines what gets returned when another file uses require() to import the module. <br>
                            Location: Every Node.js file has a module object, and module.exports is a property of it.
                        </p>
                        <div class="code-container">
                            <code>
                                1. Example: Exporting a Single Function
                                // math.js
                                function add(a, b) {
                                    &nbsp;&nbsp;return a + b;
                                }
                                module.exports = add; // Export the function


                                2. Example: Exporting Multiple Items
                                const add = (a, b) => a + b;
                                const subtract = (a, b) => a - b;
                                
                                module.exports = {
                                    &nbsp;&nbsp;add,
                                    &nbsp;&nbsp;subtract
                                }; // Export an object with multiple functions


                                3. Alternative: Using exports Shorthand
                                exports is an alias for module.exports. You can use it to add properties but cannot reassign it directly.
                                exports.add = (a, b) => a + b;
                            </code>
                        </div>
                    </article>

                    <article class="note-l2">
                        <h3>require()</h3>
                        <p>
                            require() is a function used to import modules, whether they are built-in (e.g., fs, http), installed via npm, or local files.
                        </p>

                        <div class="note-l3">
                            <h4>Syntax:</h4>
                            <p>
                                const moduleName = require('path-or-module-name');
                            </p>
                        </div>

                        <div class="code-container">
                            <code>
                                1. Example: Importing a Module
                                // app.js
                                const math = require('./math'); // Import math.js (local file, relative path)
                                
                                console.log(math.add(2, 3)); // 5

                                <hr>
                                2. Importing Built-in or npm Modules
                                const fs = require('fs'); // Built-in module
                                const express = require('express'); // npm-installed module
                            </code>
                        </div>
                    </article>

                    <article class="note-l2">
                        <h3>import</h3>
                        <p>
                            the import statement is used to bring in modules, functions, or variables from other files or packages, is part of the ECMAScript module system, introduced to standardize module handling in JavaScript. It's an alternative to the CommonJS require() system used in Node.js by default.
                        </p>

                        <div class="note-l3">
                            <h4>To use import, you must configure your project for ES Modules:</h4>
                            <ul>
                                <li>
                                    Option 1: Set <span class="bolder">"type": "module"</span> in package.json. (All .js files are treated as ES Modules, and you use import/export instead of require()/module.exports.)
                                </li>
                                <li>
                                    Option 2: Use .mjs Extension. Name your files with .mjs to explicitly indicate ES Modules, even without "type": "module". Example: app.mjs instead of app.js.
                                </li>
                            </ul>
                        </div>

                        <div class="note-l3">
                            <h4>import vs require()</h4>
                            <ul>
                                <li>
                                    We can't selectively load only the pieces we need with require but with import, we can selectively load only the pieces we need, which can save memory.
                                </li>
                                <li>
                                    Loading is synchronous for 'require' but can be asynchronous for 'import'. there are other differences also.
                                </li>
                            </ul>
                        </div>

                        <div class="code-container">
                            <code>
                                Example:
                                (use .js if "type": "module" is set in package.json file OR use .mjs)

                                1. Importing from a Local File:
                                // utils.js 
                                export const add = (a, b) => a + b;
                                export const subtract = (a, b) => a - b;

                                // app.js
                                import { add } from './utils.js';  //we can import only selective things (import add here but not subtract).
                                console.log(add(2, 3)); // 5

                                <hr>
                                2.Importing from an npm Package:
                                npm install lodash

                                // app.js
                                import { map, filter } from 'lodash'; //imported multiple
                                console.log(map([1, 2, 3], n => n * 2)); // [2, 4, 6]
                            </code>
                        </div>
                    </article>
                </div>
            </div>
        </section>

        <!-- export in directories -->
        <section id="section4" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Export in directories</h2>
                    <p>
                        When organizing large projects, you often group files into folders. You can export modules from an entire directory using a special file: index.js. It acts as the entry point of the folder.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Steps:</h3>
                        <ol>
                            <li>Create an index.js file inside the directory from which you want to export modules.</li>
                            <li>Import the modules (functions, variables, classes, etc.) from other files in that directory into index.js, and export them together using module.exports.</li>
                            <li>Import the directory (folder) wherever needed — Node.js will automatically look for index.js inside that folder.</li>
                        </ol>
                        <div class="code-container">
                            <code>
                                Example:
                                //file structure
                                project/
                                ├── utils/
                                │ ├── math.js
                                │ ├── string.js
                                │ └── index.js
                                ├── app.js

                                //utils/math.js
                                const add = (a, b) => a + b;
                                module.exports = { add };

                                // utils/string.js
                                const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
                                module.exports = { capitalize };


                                // utils/index.js
                                const math = require('./math'); import all in one file
                                const string = require('./string');

                                module.exports = { //export
                                math: math,
                                string: string
                                };


                                // app.js
                                const utils = require('./utils'); //import folder
                                
                                console.log(utils.math.add(2, 3)); // 5
                                console.log(utils.string.capitalize('hello')); // 'Hello'
                            </code>
                        </div>
                        <p>
                            There are other way also other than index.js...
                        </p>
                    </article>
                </div>
            </div>
        </section>

        <!-- export in directories -->
        <section id="section5" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>NPM (Node Package Manager)</h2>
                    <p>
                        It is default package manager for Node.js, A large online library of packages (modules), A command-line tool to install, manage, and publish packages
                    </p>
                    <div class="note-l3">
                        <p>
                            A package is like a ready-made tool or library that you can install and use in your project instead of writing
                            the code yourself.
                        </p>
                    </div>
                    <p>
                        <span class="bolder">Registry:</span> The npm registry (https://www.npmjs.com) hosts over 2 million packages, which are reusable JavaScript modules.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Installing Packages</h3>
                        <p>
                            Locally(Preffered way): <br>
                            <span class="bolder">npm install package-name</span><br>
                            OR npm i package-name (i is alias for install) <br>
                        </p>
                        <p>
                            Install in same folder of project. Locak install not work outside.
                        </p>
                        <div class="code-container">
                            <code>
                                Example:
                                npm install express
                            </code>
                        </div>
                        <p>
                            To Install globally: <br>
                            npm install -g package-name <br>
                            then use - npm link package-name (need to link with the folder in which we want to use)
                        </p>

                        <div class="notes">
                            <div class="note-l3">
                                <h4>files/folders while installing</h4>
                                <p>
                                    <span class="bolder">node_modules/</span> is the folder where all installed packages are stored. It also includes sub-dependencies — packages required by other packages. You should NOT edit anything inside this folder manually. The node modules folder contains every installed dependency for your.                        
                                </p>
                                <p>
                                    <span class="bolder">package-lock.json</span> It records the exact version of every installed dependency, including its sub-dependencies and their versions. <br>
                                    there may many other things may install...                        
                                </p>
                                <p>
                                    <span class="bolder">package.json</span> Purpose: package.json is a JSON file that stores metadata about a Node.js project, including: Project name, version, description and Dependencies e.t.c <br>
                                    There's no need to transfer the node_modules folder if package.json is present — just run npm install to reinstall all dependencies.
                                </p>
                                <p>
                                    <span class="bolder">Creating package.json with npm init:</span>
                                    Command: npm init <br>
                                    It Interactively prompts for details like name, version, description, entry point, etc. Generates a package.json file based on your input.
                                </p>
                            </div>
                        </div>
                    </article>
                </div>
            </div>
        </section>


        <!-- Express js -->
        <section id="section6" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Express.js</h2>
                    <p>
                        Express is a minimal and flexible web application framework for Node.js, designed to simplify the process of building  server-side applications and APIs.
                    </p>
                </div>
                <div class="note-l3">
                    <h4>Library</h4>
                    <p>
                        A library is a set of reusable code that you call to perform specific tasks — you control the flow of the program. e.g - axios e.t.c.
                    </p>
                </div>
                <div class="note-l3">
                    <h4>Framework</h4>
                    <p>
                        A framework is a complete structure that calls your code at the right time — it controls the flow, and you follow its rules. e.g - express e.t.c.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Setup for express:</h3>
                        <ul>
                            <li>Step 1: Create a New Project Folder</li>
                            <li>Step 2: Initialize package.json</li>
                            <li>Step 3: Install Express.js: Install Express as a dependency.</li>
                            <li>Step 4: Create a js file In the same folder.</li>
                            <li>
                                Step 5: Run Your Express App: <br>
                                In the terminal - node filename OR <br>
                                Open a browser and go to: http://localhost:portNumber <br>
                                (you can acces you local computer server using localhost)
                            </li>
                        </ul>
                        <div class="code-container">
                            <code>
                                Example code in js file:
                                const express = require('express');
                                const app = express(); 
                                //name "app" is used generally we can also use other name
                                
                                console.log(app);
                                //it shows a large object that represents the internal structure of the Express app. It includes: All built-in methods, Properties, Event listeners e.t.c.
                                
                                
                                // Define a route
                                app.get('/', (req, res) => {
                                    &nbsp;&nbsp;res.send('Hello from Express!');
                                });
                                
                                // Start the server
                                app.listen(3000, () => {
                                    &nbsp;&nbsp;console.log('Server is running at http://localhost:3000');
                                });
                            </code>
                        </div>
                        <div class="note-l3">
                            <h4>listen()</h4>
                            <p>
                                listen() is a method that starts your Express server and makes it listen for incoming requests on a specified port. <br>
                                Syntax - app.listen(port, [callback])
                            </p>
                        </div>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>nodemon</h3>
                        <p>
                            nodemon is a utility for Node.js that automatically restarts your application when file changes in the directory are detected.
                        </p>
                        <ul>
                            <li>To install - <span class="bolder">npm install -g nodemon</span> (installing globally recommended)</li>
                            <li>To run file  with <span class="bolder">nodemon - nodemon filename.js</span></li>
                        </ul>
                    </article>
                </div>
            </div>
        </section>


        <!-- Handling Requests -->
        <section id="section7" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Handling Requests in Express.js</h2>
                    <p>
                        In Express, handling requests means defining what your server should do when it receives a specific type of request (like a user visiting a page or submitting a form).
                    </p>
                </div>
                <div class="note-l3">
                    <h4>Basic Syntax:</h4>
                    <p>
                        app.METHOD(PATH, HANDLER)
                    </p>
                    <ul>
                        <li>METHOD: HTTP method (get, post, put, delete, etc.)</li>
                        <li>PATH: URL path (like '/', '/login', '/products')</li>
                        <li>HANDLER: Function that runs when the route is matched</li>
                    </ul>
                </div>
                <div class="code-container">
                    <code>
                        Example: Handling a GET Request:

                        app.get('/', (req, res) => {
                            &nbsp;&nbsp;res.send('Welcome to the homepage!');
                        });
                    </code>
                </div>
                <div class="note-l3">
                    <h4>Understanding Request & Response Objects</h4>
                    <ul>
                        <li>req → request info from the client</li>
                        <li>res → used to send a response back</li>
                    </ul>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>app.use()</h3>
                        <p>
                            app.use() is used to handle all types of requests (GET, POST, etc.) for a specific path or globally — especially useful when you want to do something before reaching the final route (like logging, authentication, etc.).
                        </p>
                        <div class="code-container">
                            <code>
                                Basic Structure example:
        
                                app.use((req, res) => {
                                    &nbsp;&nbsp;console.log('Middleware triggered');
                                });
                            </code>
                        </div>
                    </article>
                </div>
            </div>
        </section>

        <!-- Sending Response -->
        <section id="section8" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Sending Responses in Express.js</h2>
                    <p>
                        In Express, you send responses using the res (response) object, which is provided in every route handler.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Common Methods to Send Responses</h3>
                        <div class="note-l3">
                            <h4>1. res.send()</h4>
                            <p>
                                Sends a text, HTML, or object e.t.c response. Automatically sets the Content-Type based on the data type.
                            </p>
                            <div class="code-container">
                                <code>
                                    example:
                                    app.get('/', (req, res) => {
                                        &nbsp;&nbsp;res.send('/ means Home Page in paths');
                                    });
                                </code>
                            </div>
                        </div>

                        <div class="note-l3">
                            <h4>2. res.redirect()</h4>
                            <p>
                                Redirects the client to another URL. Default status is 302 (temporary redirect).
                            </p>
                            <div class="code-container">
                                <code>
                                    example:
                                    app.get('/old-route', (req, res) => {
                                        &nbsp;&nbsp;res.redirect('/new-route');
                                    });
                                </code>
                            </div>
                        </div>
                        <p>
                            There are other methods/ways also...
                        </p>
                        <p>
                            <span class="bolder">Single Response:</span> Only one response can be sent to one path per request. Calling res.send or similar methods multiple times causes an error.
                        </p>
                    </article>
                </div>
            </div>
        </section>


        <!-- Routing -->
        <section id="section9" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Routing</h2>
                    <p>
                        Routing in Express.js is the process of defining how an application responds to client requests to specific URLs (paths) using specific HTTP methods like GET, POST, etc.
                    </p>
                    <ul>
                        <li>Routes are defined using methods of the app object corresponding to HTTP methods (app.get(), app.post(), app.put(), app.delete(), etc.).</li>
                        <li>Each route maps a URL pattern to a handler function that processes the request and sends a response.</li>
                        <li>Route paths can be strings, string patterns, or regular expressions. e.g - / matches the root path, /users matches requests to /users, /user/:id matches dynamic paths like /user/123, where :id is a route parameter.</li>
                    </ul>
                    <div class="code-container">
                        <code>
                            example:
                            // GET request to the root path
                            app.get('/', (req, res) => {
                                &nbsp;&nbsp;res.send('Welcome to the homepage!');
                            });

                            // request with a route parameter
                            app.get('/user/:id', (req, res) => {
                                &nbsp;&nbsp;res.send(`User ID: ${req.params.id}`);
                            });

                            // Catch-all route for all unmatched paths
                            app.get('*', (req, res) => {
                                &nbsp;&nbsp;res.status(404).send('404 - Page Not Found');
                            });
                        </code>
                    </div>
                    <p>
                        The app.get('*', ...) route matches any GET request to any path that hasn't been handled by previous routes.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Route Parameters</h3>
                        <p>
                            In Express, route parameters (also called path parameters) allow you to capture dynamic values from the URL.
                        </p>
                        <p>
                            They are defined in the route path using a colon (:) followed by the parameter name. These parameters become available in the req.params object in your route handler.
                        </p>
                        <div class="note-l3">
                            <h4>Syntax:</h4>
                            <p>
                                app.get('/route/:paramName', (req, res) => { <br>
                                    &nbsp;&nbsp;// to Access full object - req.params <br>
                                    &nbsp;&nbsp;// to only Access paramName - req.params.paramName <br>
                                });
                            </p>
                        </div>
                        <div class="code-container">
                            <code>
                                example:
                                // Route with a path parameter
                                app.get('/users/:userId', (req, res) => {
                                    &nbsp;&nbsp;const userId = req.params.userId; // Access the parameter
                                    &nbsp;&nbsp;res.send(`User ID: ${userId}`);
                                });

                                Explanation: :userId in the route path captures the value 123 from the URL and stores it in req.params.userId.

                                <hr>
                                //Multiple Path Parameters:
                                app.get('/users/:userId/posts/:postId', (req, res) => {
                                    &nbsp;&nbsp;const { userId, postId } = req.params;
                                    &nbsp;&nbsp;res.send(`User ID: ${userId}, Post ID: ${postId}`);
                                });
                            </code>
                        </div>
                        <p>
                            <span class="bolder">Optional Parameters:</span> To make a parameter optional, add a <span class="bolder">?</span> after it.
                        </p>
                        <div class="code-container">
                            <code>
                                example:
                                //optional perematers
                                app.get('/files/:fileName?', (req, res) => {
                                    &nbsp;&nbsp;const fileName = req.params.fileName || 'default.txt';
                                    &nbsp;&nbsp;res.send(`File: ${fileName}`);
                                });

                                <hr>
                                //Regular Expression in Parameters
                                app.get('/items/:id(\\d+)', (req, res) => {
                                    &nbsp;&nbsp;const id = req.params.id;
                                    &nbsp;&nbsp;res.send(`Item ID: ${id}`);
                                });
                            </code>
                        </div>
                        <p>
                            Note - Path parameters are different from query parameters (e.g., ?key=value), which are accessed via req.query.
                        </p>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Query Strings in Express</h3>
                        <p>
                            In Express, query strings are key-value pairs in a URL that come after a ? (e.g., ?key1=value1&key2=value2). They are used to pass additional data to the server and are accessible in Express via the req.query object.
                        </p>
                        <div class="code-container">
                            <code>
                                //example syntax
                                app.get('/route', (req, res) => {
                                    &nbsp;&nbsp;// Access query parameters via req.query
                                    &nbsp;&nbsp;const queryParams = req.query;
                                    &nbsp;&nbsp;res.send(queryParams);
                                });

                                <hr>
                                example:
                                app.get('/search', (req, res) => {
                                    &nbsp;&nbsp;const { q, page } = req.query; // Destructure query parameters
                                    &nbsp;&nbsp;res.send(`Search Query: ${q}, Page: ${page || 1}`);
                                });
                                
                                <hr>
                                // Default values
                                app.get('/filter', (req, res) => {
                                    &nbsp;&nbsp;const { sort = 'asc', limit = 10 } = req.query; // Default values
                                    &nbsp;&nbsp;res.send(`Sort: ${sort}, Limit: ${limit}`);
                                });
                            </code>
                        </div>
                        <p>
                            <span class="bolder">Optional Query Parameters:</span> Query parameters are inherently optional. If not provided, req.query.key is undefined.
                        </p>
                        <table>
                            <caption>Query Strings vs. Path Parameters</caption>
                            <thead>
                                <tr>
                                    <th>Query Strings</th>
                                    <th>Path Parameters</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Optional, used for filtering, sorting, or searching (e.g., /search?q=term)</td>
                                    <td>Part of the URL path, used for identifying resources (e.g., /users/:id)</td>
                                </tr>
                                <tr>
                                    <td>req.query</td>
                                    <td>req.perams</td>
                                </tr>
                            </tbody>
                        </table>
                    </article>
                </div>
            </div>
        </section>


        <!-- GET/POST Request -->
        <section id="section10" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>GET/POST Request in express</h2>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Get Request</h3>
                        <p>
                            An HTTP method used to retrieve data from a server. It sends parameters via the URL query string (e.g., /resource?key=value).
                        </p>
                        <p>
                            In Express.js, app.get('/path', (req, res) => {...}) handles these requests, accessing parameters through req.query.
                        </p>
                        <p>
                            It's idempotent (repeated requests yield the same result), suitable for fetching resources like web pages or API data, but less secure for sensitive data as parameters are visible in URLs.
                        </p>
                        <div class="code-container">
                            <code>
                                //example:
                                //html:
                                &lt;h2&gt;GET Form&lt;/h2&gt;
                                &lt;form action="http:localhost:3000/register" method="GET"&gt;
                                    &nbsp;&nbsp;&lt;label&gt;User: &lt;input type="text" name="user"&gt;&lt;/label&gt;
                                    &nbsp;&nbsp;&lt;label&gt;Password: &lt;input type="password" name="password"&gt;&lt;/label&gt;
                                    &nbsp;&nbsp;&lt;button type="submit"&gt;Submit (GET)&lt;/button&gt;
                                &lt;/form&gt;

                                <hr>
                                // server.js
                                const express = require('express');
                                const app = express();
                                const port = 3000;
                                
                                // GET: Handle form submission
                                app.get('/register', (req, res) => {
                                    &nbsp;&nbsp;const { user, password } = req.query; //access data using req.query
                                    &nbsp;&nbsp;res.send(`GET: Welcome ${user}!`);
                                });
                                
                                app.listen(port, () => console.log(`Server on port ${port}`));
                            </code>
                        </div>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Post Request</h3>
                        <p>
                            An HTTP method used to submit data to a server to create or update resources. Data is sent in the request body, supporting formats like JSON or URL-encoded form data.
                        </p>
                        <p>
                            In Express.js, app.post('/path', (req, res) => {...}) handles these requests, accessing data via req.body (requires middleware like express.json() or express.urlencoded()).
                        </p>
                        <p>
                            It's non-idempotent (repeated requests may create multiple resources) and ideal for secure data submission, such as forms or API payloads.
                        </p>
                        <div class="code-container">
                            <code>
                                //example:
                                //html:
                                &lt;h2&gt;POST Form&lt;/h2&gt;
                                &lt;form action="http:localhost:3000/register" method="POST"&gt;
                                    &nbsp;&nbsp;&lt;label&gt;User: &lt;input type="text" name="user"&gt;&lt;/label&gt;
                                    &nbsp;&nbsp;&lt;label&gt;Password: &lt;input type="password" name="password"&gt;&lt;/label&gt;
                                    &nbsp;&nbsp;&lt;button type="submit"&gt;Submit (GET)&lt;/button&gt;
                                &lt;/form&gt;

                                <hr>
                                // server.js
                                const express = require('express');
                                const app = express();
                                const port = 3000;

                                // Middleware to parse form data and JSON
                                app.use(express.urlencoded({ extended: true }));
                                app.use(express.json());
                                //use these otherwise data is not accessible and it shows Undefined
                                
                                // POST: Handle form submission
                                app.post('/register', (req, res) => {
                                    &nbsp;&nbsp;const { user, password } = req.body; // access data using req.body
                                    &nbsp;&nbsp;res.send(`POST: Welcome ${user}!`);
                                });
                                
                                app.listen(port, () => console.log(`Server on port ${port}`));
                            </code>
                        </div>
                    </article>
                </div>
            </div>
        </section>


        <!-- Middlewares -->
        <section id="section10i" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Middlewares</h2>
                    <p>
                        Middleware refers to functions that execute during the request-response cycle. They are used to process incoming requests before they reach the route handler or send back a response.
                    </p>
                    <p>
                        Middleware is a function that has access to:
                        <ul>
                            <li>req (the request object)</li>
                            <li>res (the response object)</li>
                            <li>next (a function that passes control to the next middleware)</li>
                        </ul>
                    </p>
                    <div class="code-container">
                        <code>
                            //example syntax:
                            function middlewareName(req, res, next) {
                                &nbsp;&nbsp;// Do something
                                &nbsp;&nbsp;next(); // Pass control to next middleware
                            }
                        </code>
                    </div>
                    <p>
                        Purpose: Middlewares are used for tasks like logging, authentication, error handling, parsing request bodies, serving static files, or modifying request/response data.
                    </p>
                    <p>
                        A middleware function must either: Send a response, OR Call next() to pass control to the next middleware or route handler. If it does neither, the request will hang and the client will never get a response.
                    </p>
                    <div class="code-container">
                        <code>
                            //example:
                            const express = require('express');
                            const app = express();
                            
                            // Middleware using app.use()
                            app.use((req, res, next) => {
                            const isBlocked = true;
                            
                            if (isBlocked) {
                                &nbsp;&nbsp;// Middleware sends a response and stops further handling
                                &nbsp;&nbsp;res.status(403).send('Access Denied by Middleware'); //response sent
                            } else {
                                &nbsp;&nbsp;// Pass to the next middleware or route if not blocked
                                &nbsp;&nbsp;next();
                            }
                            });
                            
                            // This route will never run if isBlocked is true
                            app.get('/', (req, res) => {
                                &nbsp;&nbsp;res.send('Welcome to the homepage!');
                            });
                            
                            app.listen(3000, () => {
                                &nbsp;&nbsp;console.log('Server running on http://localhost:3000');
                            });


                            //app.use - Registers a middleware for all routes (/, /about, etc.)

                            <hr>
                            //using multiple middlewares:
                            const express = require('express');
                            const app = express();
                            
                            // Middleware 1 (runs first)
                            app.use((req, res, next) => {
                                &nbsp;&nbsp;console.log('Middleware 1');
                                &nbsp;&nbsp;req.msg = 'Hello';
                                &nbsp;&nbsp;next(); // Go to Middleware 2
                                &nbsp;&nbsp;//we can also write code after next here but that is not preffered as good way.
                            });
                            
                            // Middleware 2 (runs second)
                            app.use((req, res, next) => {
                                &nbsp;&nbsp;console.log('Middleware 2');
                                &nbsp;&nbsp;req.msg += ' from Middleware';
                                &nbsp;&nbsp; next(); // Go to Route Handler
                            });
                            
                            // Route Handler (runs last)
                            app.get('/', (req, res) => {
                                &nbsp;&nbsp;console.log('Route Handler');
                                &nbsp;&nbsp;res.send(req.msg + ' and Route');
                            });
                            
                            app.listen(3000);

                            <hr>
                            //middleware for specific route only:
                            app.use('/about', (req, res, next) => { //for /about route only
                                &nbsp;&nbsp;res.send('middleware for /about route only');
                                //also for like /about/xyz...
                            });
                        </code>
                    </div>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Using Middleware as Function or Variable e.t.c</h3>
                        <div class="code-container">
                            <code>
                                //example:
                                // Middleware as function
                                function logger(req, res, next) {
                                    &nbsp;&nbsp;console.log('Logger Middleware');
                                    &nbsp;&nbsp;req.msg = 'Hello';
                                    &nbsp;&nbsp;next();
                                }
                                
                                // Middleware as variable (arrow function)
                                const addText = (req, res, next) => {
                                    &nbsp;&nbsp;console.log('AddText Middleware');
                                    &nbsp;&nbsp;req.msg += ' from Variable';
                                    &nbsp;&nbsp;next();
                                };
                                
                                // Route using both middlewares
                                app.get('/', logger, addText, (req, res) => { 
                                    &nbsp;&nbsp;// pass middleware as parameter
                                    &nbsp;&nbsp;console.log('Route Handler');
                                    &nbsp;&nbsp;res.send(req.msg + ' and Route');
                                });
                                

                                Output when visiting /
                                Console:
                                Logger Middleware
                                AddText Middleware
                                Route Handler

                                Browser Response:
                                Hello from Variable and Route
                            </code>
                        </div>
                    </article>
                </div>
            </div>
        </section>

        
        <!-- Error Handeling -->
        <section id="section10ii" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Error Handeling</h2>
                    <p>
                        Error Handling refers to how Express catches and processes errors that occur both synchronously and asynchronously. Express also comes with a default error handler.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Default Error Handler</h3>
                        <p>
                            If a middleware or route throws an error or calls next(err) and you don't define a custom error handler, Express automatically returns a default 500 Internal Server Error and logs the error in the console (in development mode).
                        </p>
                        <p>
                            This default error-handling middleware function is added at the end of the middleware function stack.
                        </p>
                        <p>
                            How Does It Work Internally? -  When you throw an error or call next(err), Express Skips any remaining normal middleware and Looks for error-handling middleware (functions with 4 args: err, req, res, next) If none are found, it uses the default error handler.
                        </p>
                        <div class="code-container">
                            <code>
                                //example:
                                //No Custom Error Handler
                                const express = require('express');
                                const app = express();
                                
                                app.get('/', (req, res) => {
                                    &nbsp;&nbsp;throw new Error('Something broke!');
                                });
                                
                                app.listen(3000);

                                
                                Output:
                                Console (in development mode):
                                Error: Something broke!
                                at ...

                                Browser:
                                Cannot GET /

                                <hr>
                                //we can use also like 
                                app.get('/', (req, res, next) => {
                                    &nbsp;&nbsp;const err = new Error('Something went wrong!');
                                    &nbsp;&nbsp;next(err); // Passes the error to Express's default error handler
                                });
                            </code>
                        </div>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Custom Error Handler</h3>
                        <p>
                            To override the default error handler, define a middleware with the four arguments (err, req, res, next) typically at the end of your middleware stack.
                        </p>

                        <div class="code-container">
                            <code>
                                //example:
                                const express = require('express');
                                const app = express();
                                
                                // Normal route
                                app.get('/', (req, res) => {
                                    &nbsp;&nbsp;throw new Error('Something went wrong!');
                                    &nbsp;&nbsp;//Error middleware is called only if next(err) is used, or an error is thrown.
                                });
                                
                                // Custom error-handling middleware
                                app.use((err, req, res, next) => {
                                    &nbsp;&nbsp;console.error('Error:', err.message);
                                    &nbsp;&nbsp;res.status(500).json({ status: 'error', message: err.message });
                                });
                                
                                app.listen(3000);
                            </code>
                        </div>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Custom Error Class</h3>
                        <p>
                            A custom error class is a user-defined class that extends JavaScript's built-in Error class. It lets you attach custom properties like statusCode, status, or isOperational e.t.c to better control how errors are handled and responded to in your application.
                        </p>

                        <div class="code-container">
                            <code>
                                //example:
                                // utils/CustomError.js
                                
                                class CustomError extends Error {
                                    &nbsp;&nbsp;constructor(message, statusCode = 500) { //also we can set default parameters
                                        &nbsp;&nbsp;&nbsp;&nbsp;super(message); // Call the built-in Error constructor
                                        &nbsp;&nbsp;&nbsp;&nbsp;this.statusCode = statusCode; // HTTP status (e.g., 404, 500)
                                        &nbsp;&nbsp;&nbsp;&nbsp;this.message = message;
                                        &nbsp;&nbsp;&nbsp;&nbsp;this.isOperational = true; // Differentiates handled errors from code bugs
                                    &nbsp;&nbsp;}
                                }
                                module.exports = CustomError;
                                
                               //app.js
                                const CustomError = require('./utils/CustomError');
                                
                                app.get('/fail', (req, res, next) => {
                                    &nbsp;&nbsp;// Trigger a custom error
                                    &nbsp;&nbsp;return next(new CustomError('Something went wrong!', 400));
                                });
                            </code>
                        </div>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Handling Async errors</h3>
                        <p>
                            In Express.js, when you use async/await, any error thrown inside an async function (like a failed database query or undefined access) won't automatically be caught by Express. That's why you need to manually catch these errors and pass them to Express using next(error).
                        </p>

                        <div class="code-container">
                            <code>
                                //example 1: Using try-catch inside an async route

                                app.get("/chats", async (req, res, next) => {
                                    try {
                                        &nbsp;&nbsp;let chats = await Chat.find({});
                                        &nbsp;&nbsp;res.render("index.ejs", { chats });
                                    } catch (err) {
                                        &nbsp;&nbsp;next(err); // Pass any error to the default or custom error handler
                                    }
                                });
                                //using try-catch in async route handlers allows you to handle every different type of error that may occur in that block
                                
                                <hr>
                                //example 2: Without try-catch — using next(new ExpressError(...))
                                app.get("/chats/:id", async (req, res, next) => {
                                    &nbsp;&nbsp;let { id } = req.params;
                                    &nbsp;&nbsp;let chat = await Chat.findById(id);
                                    
                                    &nbsp;&nbsp;if (!chat) {
                                        &nbsp;&nbsp;&nbsp;&nbsp;return next(new ExpressError(404, "Chat not Found or Deleted"));
                                    &nbsp;&nbsp;}
                                    //&nbsp;&nbsp;Here, we are not able to handle all possible errors, just a specific one (chat not found).
                                
                                    &nbsp;&nbsp;res.render("edit.ejs", { chat });
                                });

                                //we can use both together also like defining specific error in try block
                            </code>
                        </div>
                    </article>
                    <div class="note-l3">
                        <h4>Async Error Wrapper</h4>
                        <p>
                            An async error wrapper is a higher-order function that wraps any async route and automatically catches errors from it and forwards them to Express's error handler.
                        </p>
                        <p>
                            The ideal approach is to use an async error wrapper, so you don't need to write try-catch everywhere.
                        </p>
                        <div class="code-container">
                            <code>
                                example syntax:
                                const asyncWrapper = (fn) => {
                                    &nbsp;&nbsp;return (req, res, next) => {
                                        &nbsp;&nbsp;&nbsp;&nbsp;Promise.resolve(fn(req, res, next)).catch(next);
                                    &nbsp;&nbsp;};
                                };
                                
                                //If fn throws an error (sync or async), .catch(next) sends it to Express's error handler.
                                //Wraps it with Promise.resolve(): Ensures that even if fn doesn't return a promise (e.g., not marked async), it's still treated as one. Safely handles both async and sync functions.

                                <hr>
                                //example:
                                //Define the Wrapper Function
                                const asyncWrapper = (fn) => {
                                    &nbsp;&nbsp;return (req, res, next) => {
                                        &nbsp;&nbsp;&nbsp;&nbsp;Promise.resolve(fn(req, res, next)).catch(next);
                                    &nbsp;&nbsp;};
                                };

                                //Use it in a Route
                                app.get('/example', asyncWrapper(async (req, res, next) => { //use it like this
                                    &nbsp;&nbsp;const data = await someAsyncFunction();
                                    &nbsp;&nbsp;res.json(data);
                                }));
                            </code>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- Error Handeling -->
        <section id="section10iii" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Schema Validation</h2>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Joi</h3>
                        <p>
                            Joi is a JavaScript object schema validation library, mainly used to validate incoming request data like: req.body (POST/PUT requests), req.params (URL parameters), req.query (query strings), This is especially useful before inserting/updating data in MongoDB, so we can prevent saving invalid or incomplete data.
                        </p>
                        <div class="code-container">
                            <code>
                                //Install:
                                npm install joi
                            </code>
                        </div>
                        <div class="code-container">
                            <code>
                                //Example:
                                //Joi Schema (for input validation)
                                const Joi = require('joi');
                                
                                const userJoiSchema = Joi.object({
                                    &nbsp;&nbsp;name: Joi.string().min(3).max(30).required(),
                                    &nbsp;&nbsp;email: Joi.string().email().required(),
                                    &nbsp;&nbsp;password: Joi.string().min(6).required(),
                                    &nbsp;&nbsp;age: Joi.number().integer().min(18).max(100).required()
                                });

                                Used to validate this incoming req.body:
                                {
                                    &nbsp;&nbsp;"name": "Inderjit",
                                    &nbsp;&nbsp;"email": "inderjit@example.com",
                                    &nbsp;&nbsp;"password": "secure123",
                                    &nbsp;&nbsp;"age": 21
                                }

                                //Without Joi:
                                if (!req.body.name) return res.status(400).send("Name is required");
                                if (!['male', 'female'].includes(req.body.gender)) return res.status(400).send("Invalid gender");
                                // ... manual checks for every field


                                //exampel Mongoose Schema according to Joi
                                const mongoose = require('mongoose');
                                
                                const userMongoSchema = new mongoose.Schema({
                                    &nbsp;&nbsp;name: { type: String,required: true,minlength: 3,maxlength: 30 },
                                    &nbsp;&nbsp;email: { type: String,required: true,unique: true // extra: ensures no duplicate emails },
                                    &nbsp;&nbsp;password: { type: String,required: true,minlength: 6 },
                                    &nbsp;&nbsp;age: { type: Number,min: 18,max: 100,required: true }
                                });
                            

                                // We use Joi so that we don't need to manually validate each field of incoming data. Joi makes validation easier, cleaner, and centralized using a schema.

                                //we use joi so that we not need to validate every incoming data object field seprately 
                                // Generally, the Joi schema and Mongoose schema need to be the same, because both describe the structure and rules for the same data model
                            </code>
                        </div>
                        <p>
                            There are other methods and libraries to validate Schema ...
                        </p>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Custom Error Handler</h3>
                        <p>
                            To override the default error handler, define a middleware with the four arguments (err, req, res, next) typically at the end of your middleware stack.
                        </p>

                        <div class="code-container">
                            <code>
                                //example:
                                const express = require('express');
                                const app = express();
                                
                                // Normal route
                                app.get('/', (req, res) => {
                                    &nbsp;&nbsp;throw new Error('Something went wrong!');
                                    &nbsp;&nbsp;//Error middleware is called only if next(err) is used, or an error is thrown.
                                });
                                
                                // Custom error-handling middleware
                                app.use((err, req, res, next) => {
                                    &nbsp;&nbsp;console.error('Error:', err.message);
                                    &nbsp;&nbsp;res.status(500).json({ status: 'error', message: err.message });
                                });
                                
                                app.listen(3000);
                            </code>
                        </div>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Custom Error Class</h3>
                        <p>
                            A custom error class is a user-defined class that extends JavaScript's built-in Error class. It lets you attach custom properties like statusCode, status, or isOperational e.t.c to better control how errors are handled and responded to in your application.
                        </p>

                        <div class="code-container">
                            <code>
                                //example:
                                // utils/CustomError.js
                                
                                class CustomError extends Error {
                                    &nbsp;&nbsp;constructor(message, statusCode = 500) { //also we can set default parameters
                                        &nbsp;&nbsp;&nbsp;&nbsp;super(message); // Call the built-in Error constructor
                                        &nbsp;&nbsp;&nbsp;&nbsp;this.statusCode = statusCode; // HTTP status (e.g., 404, 500)
                                        &nbsp;&nbsp;&nbsp;&nbsp;this.message = message;
                                        &nbsp;&nbsp;&nbsp;&nbsp;this.isOperational = true; // Differentiates handled errors from code bugs
                                    &nbsp;&nbsp;}
                                }
                                module.exports = CustomError;
                                
                               //app.js
                                const CustomError = require('./utils/CustomError');
                                
                                app.get('/fail', (req, res, next) => {
                                    &nbsp;&nbsp;// Trigger a custom error
                                    &nbsp;&nbsp;return next(new CustomError('Something went wrong!', 400));
                                });
                            </code>
                        </div>
                    </article>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Handling Async errors</h3>
                        <p>
                            In Express.js, when you use async/await, any error thrown inside an async function (like a failed database query or undefined access) won't automatically be caught by Express. That's why you need to manually catch these errors and pass them to Express using next(error).
                        </p>

                        <div class="code-container">
                            <code>
                                //example 1: Using try-catch inside an async route

                                app.get("/chats", async (req, res, next) => {
                                    try {
                                        &nbsp;&nbsp;let chats = await Chat.find({});
                                        &nbsp;&nbsp;res.render("index.ejs", { chats });
                                    } catch (err) {
                                        &nbsp;&nbsp;next(err); // Pass any error to the default or custom error handler
                                    }
                                });
                                //using try-catch in async route handlers allows you to handle every different type of error that may occur in that block
                                
                                <hr>
                                //example 2: Without try-catch — using next(new ExpressError(...))
                                app.get("/chats/:id", async (req, res, next) => {
                                    &nbsp;&nbsp;let { id } = req.params;
                                    &nbsp;&nbsp;let chat = await Chat.findById(id);
                                    
                                    &nbsp;&nbsp;if (!chat) {
                                        &nbsp;&nbsp;&nbsp;&nbsp;return next(new ExpressError(404, "Chat not Found or Deleted"));
                                    &nbsp;&nbsp;}
                                    //&nbsp;&nbsp;Here, we are not able to handle all possible errors, just a specific one (chat not found).
                                
                                    &nbsp;&nbsp;res.render("edit.ejs", { chat });
                                });

                                //we can use both together also like defining specific error in try block
                            </code>
                        </div>
                    </article>
                    <div class="note-l3">
                        <h4>Async Error Wrapper</h4>
                        <p>
                            An async error wrapper is a higher-order function that wraps any async route and automatically catches errors from it and forwards them to Express's error handler.
                        </p>
                        <p>
                            The ideal approach is to use an async error wrapper, so you don't need to write try-catch everywhere.
                        </p>
                        <div class="code-container">
                            <code>
                                example syntax:
                                const asyncWrapper = (fn) => {
                                    &nbsp;&nbsp;return (req, res, next) => {
                                        &nbsp;&nbsp;&nbsp;&nbsp;Promise.resolve(fn(req, res, next)).catch(next);
                                    &nbsp;&nbsp;};
                                };
                                
                                //If fn throws an error (sync or async), .catch(next) sends it to Express's error handler.
                                //Wraps it with Promise.resolve(): Ensures that even if fn doesn't return a promise (e.g., not marked async), it's still treated as one. Safely handles both async and sync functions.

                                <hr>
                                //example:
                                //Define the Wrapper Function
                                const asyncWrapper = (fn) => {
                                    &nbsp;&nbsp;return (req, res, next) => {
                                        &nbsp;&nbsp;&nbsp;&nbsp;Promise.resolve(fn(req, res, next)).catch(next);
                                    &nbsp;&nbsp;};
                                };

                                //Use it in a Route
                                app.get('/example', asyncWrapper(async (req, res, next) => { //use it like this
                                    &nbsp;&nbsp;const data = await someAsyncFunction();
                                    &nbsp;&nbsp;res.json(data);
                                }));
                            </code>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- EJS -->
        <section id="section11" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>EJS(Embedded JavaScript)</h2>
                    <p>
                        EJS (Embedded JavaScript) is a templating engine for Node.js that lets you generate HTML dynamically by embedding JavaScript directly in your templates. It's lightweight, works well with Express.js, and is great for rendering dynamic web pages with data from your server.
                    </p>
                    <p>
                        File Extension - <span class="bolder">.ejs</span>
                    </p>
                    <p>
                        To Install - <span class="bolder">npm install ejs</span> <br>
                        We need to require express to use this because it automatically requires ejs.
                    </p>
                    <div class="code-container">
                        <code>
                            Example setup:
                            const express = require('express');
                            const app = express();
                            
                            // Set EJS as the templating engine
                            app.set('view engine', 'ejs');

                            app.set('views', './views');  
                            // Setting the folder for EJS templates (commonly named 'views', but you can use any folder name)

                            OR
                            app.set('views', './templates'); // if your EJS files are in a 'templates' folder
                        </code>
                    </div>
                    <div class="note-l3">
                        <h4>to run ejs from other directory:</h4>
                        <p>
                            To run an EJS-based Express app from a parent directory, you need to ensure the Express server correctly locates the EJS templates and other resources, even when the server is started from a directory outside the project folder.
                        </p>
                        <div class="code-container">
                            <code>
                                example:
                                const express = require('express');
                                const path = require('path'); //require path first
                                const app = express();
                                app.set('view engine', 'ejs');

                                // Set the views directory using an absolute path
                                app.set('views', path.join(__dirname, 'views')); //set this always
                            </code>
                        </div>
                    </div>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>res.render()</h3>
                        <p>
                            The res.render method in Express.js is used to render a view template (like an EJS file) and send the resulting HTML to the client.
                        </p>
                        <div class="note-l3">
                            <h4>Syntax:</h4>
                            <p>
                                <span class="bolder">res.render('templateName', dataObject);</span><br>
                                'templateName' → the name of your .ejs file (without .ejs) <br>
                                dataObject → an optional object containing data to use in the template.
                            </p>
                        </div>
                        <div class="code-container">
                            <code>
                                example:
                                const express = require("express");
                                const app = express();
                                const path = require("path");
                                
                                app.set("view engine", "ejs");
                                app.set("views", path.join(__dirname, "views"));
                                
                                //this
                                app.get("/", (req, res) => {
                                    &nbsp;&nbsp;res.render("home", { name: "Inderjit", age: 20 });
                                });

                                //OR like this
                                app.get("/support", (req, res) => {
                                    &nbsp;&nbsp;res.render("support");
                                });
                                
                                app.listen(3000, () => {
                                    &nbsp;&nbsp;console.log("Server running on http://localhost:3000");
                                });
                            </code>
                        </div>
                    </article>
                </div>
            </div>
        </section>


        <!-- Interpolation Syntax -->
        <section id="section12" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Interpolation Syntax</h2>
                    <p>
                        Interpolation syntax in EJS refers to the method of embedding dynamic values (such as variables or expressions or server-side values) directly into HTML templates using special EJS tags. It allows server-side data to be inserted into the rendered HTML output.
                    </p>
                    <div class="notes">
                        <article class="note-l2">
                            <h3>There are two main interpolation tags:</h3>
                            <div class="note-l3">
                                <p>
                                    <h4>1. &lt;%= %&gt; — Escaped Output Tag</h4>
                                </p>
                                <p>
                                    Prints the evaluated value of a variable or expression. HTML characters like &lt;,&gt;, &, etc., are escaped (converted to safe entities like &amp;lt;). Safe to use with user data to prevent XSS (cross-site scripting).
                                </p>
                                <div class="code-container">
                                    <code>
                                        example:
                                        &lt;%= "&lt;h1&gt;Welcome&lt;/h1&gt;" %&gt;

                                        //output for html:
                                        &amp;lt;h1&amp;gt;Welcome&amp;lt;/h1&amp;gt;
                                        //It shows the string as plain text, not HTML.

                                        //in browser
                                        &lt;h1&gt;Welcome&lt;/h1&gt;
                                    </code>
                                </div>
                            </div>
                            <div class="note-l3">
                                <p>
                                    <h4>2. &lt;%- %&gt; — Unescaped Output Tag</h4>
                                </p>
                                <p>
                                    Prints the evaluated value as raw HTML. Useful when you want to render actual HTML from a variable. Not safe for user input unless sanitized — it can expose your page to XSS attacks.
                                </p>
                                <div class="code-container">
                                    <code>
                                        example:
                                        &lt;%- "&lt;h1&gt;Welcome&lt;/h1&gt;" %&gt;

                                        //output for html:
                                        &lt;h1&gt;Welcome&lt;/h1&gt;
                                        //It shows in bold after h1 works.

                                        //in browser
                                        <h1>Welcome</h1>
                                    </code>
                                </div>
                            </div>
                        </article>
                    </div>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Control & Utility Tags</h3>
                        <p>
                            Used for Logic or Structure. These tags are used not to display data, but to control the flow of logic, structure your templates, or manage whitespace/comments. These are essential for adding loops, conditions, comments, and clean formatting in templates.
                        </p>
                        <div class="note-l3">
                            <h4>1. &lt;% %&gt; - Scriptlet Tag (Control-Flow, No Output)</h4>
                            <p>
                                Executes JavaScript for control flow (e.g., loops, conditionals, variable assignments) without directly outputting to the HTML.
                            </p>
                            <div class="code-container">
                                <code>
                                    example:
                                    &lt;% if (user.isAdmin) { %&gt;
                                        &nbsp;&nbsp;&lt;p&gt; Welcome, Admin! &lt;/p&gt;
                                    &lt;% } %&gt;
                                </code>
                            </div>
                        </div>
                        <div class="note-l3">
                            <h4>2. &lt;%_ %&gt; - Whitespace Slurping Scriptlet Tag</h4>
                            <p>
                                Removes all whitespace (spaces, newlines) before the tag, useful for clean HTML output.
                            </p>
                            <div class="code-container">
                                <code>
                                    example:
                                    &lt;ul&lt;
                                        &nbsp;&nbsp;&lt;%_ notes.forEach(note => { %&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;%= note.title %&gt;&lt;/li&gt;
                                        &nbsp;&nbsp;&lt;%_ }) %&gt;
                                    &lt;/ul&gt;

                                    //output for html like:
                                    &lt;ul&gt;
                                        &nbsp;&nbsp;&lt;li&gt;JavaScript Async/Await&lt;/li&gt;
                                    &lt;/ul&gt;

                                    //without it may like:
                                    &lt;ul&gt;

                                        &nbsp;&nbsp;&lt;li&gt;JavaScript Async/Await&lt;/li&gt;
                                    &lt;/ul&gt;
                                </code>
                            </div>
                        </div>
                        <div class="note-l3">
                            <h4>3. &lt;%# %&gt; - Comment Tag</h4>
                            <p>
                                Adds comments in EJS that are not included in the rendered HTML and are not executed.
                            </p>
                            <div class="code-container">
                                <code>
                                    example:
                                    &lt;%# This is a comment, not visible in the HTML %&gt;
                                    &lt;p&gt;Visible content&lt;/p&gt;

                                    //output for html like:
                                    &lt;p&gt;Visible content&lt;/p&gt;
                                </code>
                            </div>
                        </div>
                        <div class="note-l3">
                            <h4>4. &lt;%% %&gt; - Outputs a Literal</h4>
                            <p>
                                Escapes the &lt;% delimiter, rendering it as literal text in the output. If you want to print a literal &lt;% in the HTML (for educational content or documentation), use &lt;%%.
                            </p>
                            <div class="code-container">
                                <code>
                                    example:
                                    &lt;%%= "example" %&gt;

                                    //output:
                                    &lt;%= "example" %&gt;
                                </code>
                            </div>
                        </div>
                        <div class="note-l3">
                            <h4>5. %&gt; - Plain Ending Tag</h4>
                            <p>
                                Closes any EJS tag (&lt;%, &lt;%_, &lt;%=, &lt;%-, etc.).
                            </p>
                        </div>
                        <div class="note-l3">
                            <h4>6. -%&gt; - Trim-Mode (Newline Slurp) Tag</h4>
                            <p>
                                Removes the newline character after the tag, reducing extra line breaks in the output, helping keep HTML compact.
                            </p>
                            <div class="code-container">
                                <code>
                                    example:
                                    &lt;ul&lt;
                                        &nbsp;&nbsp;&lt;%_ notes.forEach(note => { %&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;%= note.title %&gt;&lt;/li&gt;
                                        &nbsp;&nbsp;&lt;%_ }) %&gt;
                                    &lt;/ul&gt;
                                    
                                    //output for html like:
                                    &lt;ul&gt;
                                        &nbsp;&nbsp;&lt;li&gt;JavaScript Async/Await&lt;/li&gt;
                                    &lt;/ul&gt;
                                    
                                    //without it may like:
                                    &lt;ul&gt;
                                    
                                        &nbsp;&nbsp;&lt;li&gt;JavaScript Async/Await&lt;/li&gt;
                                    &lt;/ul&gt;
                                </code>
                            </div>
                        </div>
                        <div class="note-l3">
                            <h4>7. _%&gt; - Whitespace Slurping Ending Tag</h4>
                            <p>
                                Like -%&gt;, but removes all whitespace after the tag, not just the newline. Useful for super clean output.
                            </p>
                            <div class="code-container">
                                <code>
                                    example:
                                    &lt;ul&lt;
                                        &nbsp;&nbsp;&lt;%_ notes.forEach(note => { %&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;%= note.title %&gt;&lt;/li&gt;
                                        &nbsp;&nbsp;&lt;%_ }) %&gt;
                                    &lt;/ul&gt;
                                    
                                    //output for html like:
                                    &lt;ul&gt;
                                        &nbsp;&nbsp;&lt;li&gt;JavaScript&lt;/li&gt;&lt;li&gt;Python&lt;/li&gt;
                                    &lt;/ul&gt;
                                </code>
                            </div>
                        </div>
                    </article>
                </div>
            </div>
        </section>

        <!-- Passing Data to ejs -->
        <section id="section13" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Passing data to ejs</h2>
                    <p>
                        In EJS, data is passed from the Express server to the template via the res.render method.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>res.render()</h3>
                        <p>
                            The res.render method in Express.js is used to render a view template (like an EJS file) and send the resulting HTML to the client.
                        </p>
                        <div class="note-l3">
                            <h4>Syntax:</h4>
                            <p>
                                <span class="bolder">res.render('templateName', dataObject);</span><br>
                                'templateName' → the name of your .ejs file (without .ejs) <br>
                                dataObject → an optional object containing data to use in the template.
                            </p>
                        </div>
                        <div class="code-container">
                            <code>
                                example:
                                const express = require("express");
                                const app = express();
                                const path = require("path");
                                app.set("view engine", "ejs");
                                app.set("views", path.join(__dirname, "views"));
                                

                                app.get("/", (req, res) => {
                                    &nbsp;&nbsp;res.render("home", { name: "Inderjit", age: 20 });
                                });
                                
                                app.listen(3000, () => {
                                    &nbsp;&nbsp;console.log("Server running on http://localhost:3000");
                                });


                                //views/home.ejs
                                &lt;p&gt;Welcome, &lt;%= name %&gt;!&lt;/p&gt;
                                &lt;p&gt;Your age is &lt;%= age %&gt;.&lt;/p&gt;

                                //output:
                                <p style="all: unset;">Welcome, Inderjit!</p>
                                <p style="all: unset;">Your age is 20.</p>
                            </code>
                        </div>
                        <p>
                            In EJS, the variable name in the template and the key in the object passed to <code>res.render()</code> should match.
                        </p>
                        <p>
                            If the key and value names are the same in the object, you can use shorthand syntax and write only one.
                        </p>
                        <div class="code-container">
                            <code>
                                Example:
                                app.get("/", (req, res) => {
                                    &nbsp;&nbsp;const random = Math.random();
                                    &nbsp;&nbsp;res.render("home", { random });  // shorthand for { random: random }
                                });
                          
                                // views/home.ejs
                                &lt;p&gt;Random number: &lt;%= random %&gt;&lt;/p&gt;
                            </code>
                        </div>                          
                    </article>
                </div>
            </div>
        </section>


        <!-- Includes -->
        <section id="section14" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Include</h2>
                    <p>
                        In EJS , the <span class="bolder">&lt;%- include %&gt;</span> syntax is used to include one EJS file inside another. This is helpful for reusing common layouts like headers, footers, or navigation menus.
                    </p>
                    <div class="note-l3">
                        <h4>Syntax:</h4>
                        <p>
                            &lt;%- include('path/to/file') %&gt;
                        </p>
                    </div>
                    <div class="code-container">
                        <code>
                            example:
                            //index.ejs:
                            &lt;%- include('partials/header') %&gt; //include header ejs
                            &lt;p&gt;Welcome to My Website&lt;/p&gt;
                            &lt;%- include('partials/footer') %&gt; //include footer ejs

                            //header.ejs:
                            &lt;header&gt;
                                &nbsp;&nbsp;&lt;p&gt;This is the header&lt;/p&gt;
                            &lt;/header&gt;

                            //footer.ejs:
                            &lt;footer&gt;
                                &nbsp;&nbsp;&lt;p&gt;Footer content goes here&lt;/p&gt;
                            &lt;/footer&gt;

                            <hr>
                            //after rendering like:
                            &lt;header&gt;
                                &nbsp;&nbsp;&lt;p&gt;This is the header&lt;/p&gt;
                            &lt;/header&gt;
                            &lt;p&gt;Welcome to My Website&lt;/p&gt;
                            &lt;footer&gt;
                                &nbsp;&nbsp;&lt;p&gt;Footer content goes here&lt;/p&gt;
                            &lt;/footer&gt;

                            <hr>
                            //in browser like:
                            <p style="all: unset;">This is the header</p>
                            <p style="all: unset;">Welcome to My Website</p>
                            <p style="all: unset;">Footer content goes here</p>
                        </code>
                    </div>
                    <p>
                        Use different folder for these files like above partials folder is used or you can use "includes" also as folder name.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Passing Data to Includes</h3>
                        <p>
                            You can pass variables to included files by adding a second argument to include like:
                        </p>
                        <div class="code-container">
                            <code>
                                Example:
                                &lt;%- include('header', { title: 'My Custom Title' }) %&gt;
                                //same like passing data to ejs
                                
                                In header.ejs, you can use the passed variable like:
                                &lt;header&gt;
                                    &lt;h1&gt; &lt;%= title %&gt; &lt;/h1&gt;
                                &lt;/header&gt;
                            </code>
                        </div>              
                    </article> 
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>ejs-mate package</h3>
                        <p>
                            ejs-mate is like an upgrade kit for EJS — it gives your EJS templates superpowers such as layouts, reusable page parts, and content placeholders so you don't have to repeat the same HTML structure on every page. By using ejs-mate, you can define a base layout and have individual views “extend” it.
                        </p>
                        <p>
                            &lt;% layout('layoutFileName') -%&gt; <br>
                            Must be at the top of your .ejs file. layoutFileName is relative to your views folder (no .ejs extension needed). This tells ejs-mate which master template to use.
                        </p>
                        <div class="code-container">
                            <code>
                                Installation & Setup Example:
                                npm install ejs-mate

                                //add this also:
                                const engine = require('ejs-mate'); //or any name in place of engine
                                app.engine('ejs', engine);

                                <hr>
                                Example Layout Workflow:
                                // views/layout.ejs (master layout):
                                &lt;html&gt;
                                &lt;head&gt;
                                    &lt;title&gt;&lt;%- title %&gt;&lt;/title&gt;
                                &lt;/head&gt;
                                &lt;body&gt;
                                    &lt;%- body %&gt;
                                &lt;/body&gt;
                                &lt;/html&gt;
                                
                                // views/pages/home.ejs (child template):
                                &lt;% layout('layout') -%&gt;
                                &lt;h1&gt;Hello from Home Page&lt;/h1&gt;
                                &lt;p&gt;This is simple EJS-Mate in action!&lt;/p&gt;


                                //If you render home.ejs, it will insert the h1 and p into the &lt;%- body %&gt; spot in layout.ejs.
                            </code>
                        </div>              
                    </article> 
                </div>
            </div>
        </section>


        <!-- REST -->
        <section id="section15" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>REST</h2>
                    <p>
                        REST (Representational State Transfer) is a widely used architectural style for designing web APIs, networked applications, particularly web services. It relies on a stateless, client-server communication model, usually over HTTP.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Key principles include:</h3>
                        <ul>
                            <li><span class="bolder">Resource-Based:</span> Everything is treated as a resource, and each resource is identified by a URI (Uniform Resource Identifier), like /users/1.</li>
                            <li><span class="bolder">Stateless:</span> Each request from a client to a server must contain all the information needed to process it.</li>
                            <li><span class="bolder">Client-Server Architecture:</span> The client and server operate independently. The client handles the user interface, and the server manages data and logic.</li>
                            <li><span class="bolder">Representation:</span> Resources are represented in formats such as JSON, XML, or HTML. The client interacts with the resource by using these representations.</li>
                            <li><span class="bolder">Stateless Communication:</span> No session data is stored on the server. Every request is independent.</li>
                            <li>
                                <span class="bolder">Uniform Interface:</span> A consistent way to access resources using standard HTTP methods - (CRUD operations):- <br> 
                                To Retrieve data - GET (e.g., GET /users/123) <br> 
                                To Create new data - POST (e.g., POST /users)<br>
                                To Update data - PUT (e.g., PUT /users/123)<br>
                                To Remove data - DELETE (e.g., DELETE /users/123)<br>
                                To Partially update a resource - PATCH
                            </li>
                        </ul>        
                    </article> 
                </div>
            </div>
        </section>


        <!-- Unique IDs -->
        <section id="section16" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>How to Creaete Unique IDs</h2>
                    <p>
                        To create unique IDs in your Express app (e.g. for each post), you have a few good options depending on how unique, readable, or persistent you want them to be.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>1. Use crypto.randomUUID() (Built-in Node.js)</h3>
                        <div class="code-container">
                            <code>
                                Use Like:
                                //1.require:
                                const { randomUUID } = require('crypto');

                                //2.use
                                const newPost = {
                                    &nbsp;&nbsp;id: randomUUID(), //this
                                    &nbsp;&nbsp;username: "alice",
                                    &nbsp;&nbsp;content: "Hello world"
                                };

                                //Produces something like:
                                "3f50d2b7-9a7e-40ae-9f0c-5071d2e426f5"

                                //these are Universally unique, No extra dependencies
                            </code>
                        </div> 
                    </article> 
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>2. Use the uuid package (Very common in real projects)</h3>
                        <div class="code-container">
                            <code>
                                Use Like:
                                //1.Install It:
                                npm install uuid

                                //2.require:
                                const { v4: uuidv4 } = require('uuid');

                                //3.use
                                const newPost = {
                                    &nbsp;&nbsp;id: uuidv4(), //this
                                    &nbsp;&nbsp;username: "bob",
                                    &nbsp;&nbsp;content: "Hello world"
                                };

                                Output is similar to randomUUID().
                            </code>
                        </div> 
                    </article> 
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>3. Use a Simple Counter (for testing or in-memory arrays)</h3>
                        <p>
                            If you don't care about global uniqueness and just want simple incremental IDs (for development/testing only).
                        </p>
                        <div class="code-container">
                            <code>
                                Use Like:
                                let idCounter = 1;

                                const newPost = {
                                    &nbsp;&nbsp;id: idCounter++,
                                    &nbsp;&nbsp;username: "test",
                                    &nbsp;&nbsp;content: "Simple ID test"
                                };

                                //IDs will reset every time the server restarts — not recommended for real use.
                            </code>
                        </div> 
                        <p>
                            There are many other methods also...
                        </p>
                    </article> 
                </div>
            </div>
        </section>


        <!-- Method Override -->
        <section id="section17" class="note-section" tabindex="0">
            <div class="container">
                <div class="note-l1">
                    <h2>Use PUT, PATCH, DELETE in html</h2>
                    <p>
                        Since HTML forms only support GET and POST methods via method attribute, but Express.js supports all HTTP methods (GET, POST, PUT, PATCH, DELETE), here's how you can use PUT, PATCH, and DELETE in HTML forms using a common workaround.
                    </p>
                </div>
                <div class="notes">
                    <article class="note-l2">
                        <h3>Method Override in Express</h3>
                        <p>
                            Use a middleware called method-override.
                        </p>
                        <div class="code-container">
                            <code>
                                Step by step guide:
                                1. Install method-override:
                                npm install method-override


                                2. Set up in your Express app:
                                const methodOverride = require('method-override'); //require it

                                app.use(methodOverride('_method')); // looks for _method in form fields
                                //also we can use other name than _method but this is commom
                                

                                3. Write HTML Form with POST but include _method hidden field:
                                &lt;form action="/users/1?_method=PUT" method="POST"&gt; //use ?_method=PUT
                                    &nbsp;&nbsp;//form fields
                                &lt;/form&gt;

                                Or using hidden input:
                                &lt;form action="/users/1" method="POST"&gt;
                                    &nbsp;&nbsp;&lt;input type="hidden" name="_method" value="PUT"&gt;
                                    &nbsp;&nbsp;//other form fields
                                &lt;/form&gt;

                                Similarly, use _method=PATCH or _method=DELETE for other methods.

                                
                                4. Define routes in Express:
                                app.put('/users/:id', (req, res) => { //use method you want to use
                                    &nbsp;&nbsp;res.send('User updated');
                                });                                  
                            </code>
                        </div> 
                        <p>
                            There are other ways also...
                        </p>
                    </article> 
                </div>
            </div>
        </section>
    </main>

    <script>
        // Toggle sidebar for mobile
        const menuToggle = document.querySelector('.menu-toggle');
        const sidebar = document.querySelector('.sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('active');
        });
    </script>
</body>

</html>




























































<template>

<section id="section1" class="note-section" tabindex="0">
    <div class="container">
        <!-- lvl 1 -->
        <div class="note-l1">
            <h2>Node.js Basics</h2>
            <p>
                Essential concepts and methods for building server-side applications with Node.js.
            </p>
        </div>
        <div class="notes">
            <!-- lvl 2  -->
            <article class="note-l2">
                <h3>require()</h3>
                <p>
                    Import modules or files into your Node.js application.
                </p>
                <div class="code-container">
                    <code>
                        Syntax:
                        const module = require('module-name');
                        // Imports a module
                    </code>
                </div>
                <div class="notes">
                    <!-- lvl 3  -->
                    <div class="note-l3">
                        <h4>Example:</h4>
                        <p>
                            Importing the built-in 'fs' module to work with the file system.
                        </p>
                        <div class="code-container">
                            <code>
                                const fs = require('fs');
                                // Use fs to read/write files
                            </code>
                        </div>
                    </div>

                    <!-- lvl 3 -->
                    <div class="note-l3">
                        <h4>Tip:</h4>
                        <p>
                            Use relative paths (e.g., './module') for local modules.
                        </p>
                    </div>
                </div>
            </article>

            <!-- lvl 2  -->
            <article class="note-l2">
                <h3>module.exports</h3>
                <p>
                    Export functions, objects, or values from a module to be used elsewhere.
                </p>
                <div class="code-container">
                    <code>
                        Syntax:
                        module.exports = { functionName };
                        // Exports a function or object
                    </code>
                </div>
                <div class="notes">
                    <!-- lvl 3 -->
                    <div class="note-l3">
                        <h4>Example:</h4>
                        <p>
                            Exporting a function from a module.
                        </p>
                        <div class="code-container">
                            <code>
                                // math.js
                                module.exports = {
                                    add: (a, b) => a + b
                                };
                                // In another file:
                                const math = require('./math');
                                console.log(math.add(2, 3)); // Output: 5
                            </code>
                        </div>
                    </div>
                    <!-- lvl 3 -->
                    <div class="note-l3">
                        <h4>Note:</h4>
                        <p>Use <code>exports</code> for multiple exports, but avoid overwriting
                            <code>module.exports</code>.
                        </p>
                    </div>
                </div>
            </article>
        </div>
    </div>
</section>

<section id="section6" class="note-section" tabindex="0">
    <div class="container">
        <div class="note-l1">
            <h2>Extras: Tables & Lists</h2>
            <p>
                Examples of HTML tables, unordered and ordered lists used in notes.
            </p>
        </div>

        <div class="notes">
            <!-- table lvl 2 -->
            <article class="note-l2">
                <h3>Example Table</h3>
                <p>
                    Simple data representation using HTML tables.
                </p>
                <!-- table -->
                <table>
                    <caption>Node.js Module Types</caption>
                    <thead>
                        <tr>
                            <th>Module Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Core Modules</td>
                            <td>Built-in modules provided by Node.js (e.g., fs, http).</td>
                        </tr>
                        <tr>
                            <td>Local Modules</td>
                            <td>Modules created within your project.</td>
                        </tr>
                        <tr>
                            <td>Third-Party Modules</td>
                            <td>Modules installed via npm (e.g., express).</td>
                        </tr>
                    </tbody>
                </table>
            </article>

            <!-- ul lvl 2 -->
            <article class="note-l2">
                <h3>Unordered List (ul)</h3>
                <p>Key features of Node.js:</p>
                <ul>
                    <li>Asynchronous and Event-Driven</li>
                    <li>Single-Threaded but Highly Scalable</li>
                    <li>Fast Execution with V8 Engine</li>
                    <li>Open-source and Community Driven</li>
                </ul>
            </article>

            <!-- ol lvl 2 -->
            <article class="note-l2">
                <h3>Ordered List (ol)</h3>
                <p>Steps to create a simple Node.js server:</p>
                <ol>
                    <li>Initialize project with <code>npm init</code></li>
                    <li>Create a JavaScript file (e.g., <code>app.js</code>)</li>
                    <li>Import <code>http</code> module</li>
                    <li>Create server using <code>http.createServer()</code></li>
                    <li>Listen on a specific port using <code>server.listen()</code></li>
                </ol>
            </article>
        </div>
    </div>
</section>

</template>